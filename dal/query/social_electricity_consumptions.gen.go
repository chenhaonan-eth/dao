// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"github.com/chenhaonan-eth/dao/dal/model"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newSocialElectricityConsumption(db *gorm.DB, opts ...gen.DOOption) socialElectricityConsumption {
	_socialElectricityConsumption := socialElectricityConsumption{}

	_socialElectricityConsumption.socialElectricityConsumptionDo.UseDB(db, opts...)
	_socialElectricityConsumption.socialElectricityConsumptionDo.UseModel(&model.SocialElectricityConsumption{})

	tableName := _socialElectricityConsumption.socialElectricityConsumptionDo.TableName()
	_socialElectricityConsumption.ALL = field.NewAsterisk(tableName)
	_socialElectricityConsumption.Date = field.NewString(tableName, "date")
	_socialElectricityConsumption.WholeSociety = field.NewString(tableName, "whole_society")
	_socialElectricityConsumption.WholeSocietyYearOnYear = field.NewString(tableName, "whole_society_year_on_year")
	_socialElectricityConsumption.AllIndustries = field.NewString(tableName, "all_industries")
	_socialElectricityConsumption.AllIndustriesYearOnYear = field.NewString(tableName, "all_industries_year_on_year")
	_socialElectricityConsumption.PrimaryIndustry = field.NewString(tableName, "primary_industry")
	_socialElectricityConsumption.PrimaryIndustryYearOnYear = field.NewString(tableName, "primary_industry_year_on_year")
	_socialElectricityConsumption.SecondaryIndustry = field.NewString(tableName, "secondary_industry")
	_socialElectricityConsumption.SecondaryIndustryYearOnYear = field.NewString(tableName, "secondary_industry_year_on_year")
	_socialElectricityConsumption.TertiaryIndustry = field.NewString(tableName, "tertiary_industry")
	_socialElectricityConsumption.TertiaryIndustryYearOnYear = field.NewString(tableName, "tertiary_industry_year_on_year")
	_socialElectricityConsumption.CitiesAndVillages = field.NewString(tableName, "cities_and_villages")
	_socialElectricityConsumption.CitiesAndVillagesYearOnYear = field.NewString(tableName, "cities_and_villages_year_on_year")
	_socialElectricityConsumption.Cities = field.NewString(tableName, "cities")
	_socialElectricityConsumption.CitiesYearOnYear = field.NewString(tableName, "cities_year_on_year")
	_socialElectricityConsumption.Villages = field.NewString(tableName, "villages")
	_socialElectricityConsumption.VillagesYearOnYear = field.NewString(tableName, "villages_year_on_year")

	_socialElectricityConsumption.fillFieldMap()

	return _socialElectricityConsumption
}

type socialElectricityConsumption struct {
	socialElectricityConsumptionDo socialElectricityConsumptionDo

	ALL                         field.Asterisk
	Date                        field.String
	WholeSociety                field.String
	WholeSocietyYearOnYear      field.String
	AllIndustries               field.String
	AllIndustriesYearOnYear     field.String
	PrimaryIndustry             field.String
	PrimaryIndustryYearOnYear   field.String
	SecondaryIndustry           field.String
	SecondaryIndustryYearOnYear field.String
	TertiaryIndustry            field.String
	TertiaryIndustryYearOnYear  field.String
	CitiesAndVillages           field.String
	CitiesAndVillagesYearOnYear field.String
	Cities                      field.String
	CitiesYearOnYear            field.String
	Villages                    field.String
	VillagesYearOnYear          field.String

	fieldMap map[string]field.Expr
}

func (s socialElectricityConsumption) Table(newTableName string) *socialElectricityConsumption {
	s.socialElectricityConsumptionDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s socialElectricityConsumption) As(alias string) *socialElectricityConsumption {
	s.socialElectricityConsumptionDo.DO = *(s.socialElectricityConsumptionDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *socialElectricityConsumption) updateTableName(table string) *socialElectricityConsumption {
	s.ALL = field.NewAsterisk(table)
	s.Date = field.NewString(table, "date")
	s.WholeSociety = field.NewString(table, "whole_society")
	s.WholeSocietyYearOnYear = field.NewString(table, "whole_society_year_on_year")
	s.AllIndustries = field.NewString(table, "all_industries")
	s.AllIndustriesYearOnYear = field.NewString(table, "all_industries_year_on_year")
	s.PrimaryIndustry = field.NewString(table, "primary_industry")
	s.PrimaryIndustryYearOnYear = field.NewString(table, "primary_industry_year_on_year")
	s.SecondaryIndustry = field.NewString(table, "secondary_industry")
	s.SecondaryIndustryYearOnYear = field.NewString(table, "secondary_industry_year_on_year")
	s.TertiaryIndustry = field.NewString(table, "tertiary_industry")
	s.TertiaryIndustryYearOnYear = field.NewString(table, "tertiary_industry_year_on_year")
	s.CitiesAndVillages = field.NewString(table, "cities_and_villages")
	s.CitiesAndVillagesYearOnYear = field.NewString(table, "cities_and_villages_year_on_year")
	s.Cities = field.NewString(table, "cities")
	s.CitiesYearOnYear = field.NewString(table, "cities_year_on_year")
	s.Villages = field.NewString(table, "villages")
	s.VillagesYearOnYear = field.NewString(table, "villages_year_on_year")

	s.fillFieldMap()

	return s
}

func (s *socialElectricityConsumption) WithContext(ctx context.Context) *socialElectricityConsumptionDo {
	return s.socialElectricityConsumptionDo.WithContext(ctx)
}

func (s socialElectricityConsumption) TableName() string {
	return s.socialElectricityConsumptionDo.TableName()
}

func (s socialElectricityConsumption) Alias() string { return s.socialElectricityConsumptionDo.Alias() }

func (s *socialElectricityConsumption) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *socialElectricityConsumption) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 17)
	s.fieldMap["date"] = s.Date
	s.fieldMap["whole_society"] = s.WholeSociety
	s.fieldMap["whole_society_year_on_year"] = s.WholeSocietyYearOnYear
	s.fieldMap["all_industries"] = s.AllIndustries
	s.fieldMap["all_industries_year_on_year"] = s.AllIndustriesYearOnYear
	s.fieldMap["primary_industry"] = s.PrimaryIndustry
	s.fieldMap["primary_industry_year_on_year"] = s.PrimaryIndustryYearOnYear
	s.fieldMap["secondary_industry"] = s.SecondaryIndustry
	s.fieldMap["secondary_industry_year_on_year"] = s.SecondaryIndustryYearOnYear
	s.fieldMap["tertiary_industry"] = s.TertiaryIndustry
	s.fieldMap["tertiary_industry_year_on_year"] = s.TertiaryIndustryYearOnYear
	s.fieldMap["cities_and_villages"] = s.CitiesAndVillages
	s.fieldMap["cities_and_villages_year_on_year"] = s.CitiesAndVillagesYearOnYear
	s.fieldMap["cities"] = s.Cities
	s.fieldMap["cities_year_on_year"] = s.CitiesYearOnYear
	s.fieldMap["villages"] = s.Villages
	s.fieldMap["villages_year_on_year"] = s.VillagesYearOnYear
}

func (s socialElectricityConsumption) clone(db *gorm.DB) socialElectricityConsumption {
	s.socialElectricityConsumptionDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s socialElectricityConsumption) replaceDB(db *gorm.DB) socialElectricityConsumption {
	s.socialElectricityConsumptionDo.ReplaceDB(db)
	return s
}

type socialElectricityConsumptionDo struct{ gen.DO }

func (s socialElectricityConsumptionDo) Debug() *socialElectricityConsumptionDo {
	return s.withDO(s.DO.Debug())
}

func (s socialElectricityConsumptionDo) WithContext(ctx context.Context) *socialElectricityConsumptionDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s socialElectricityConsumptionDo) ReadDB() *socialElectricityConsumptionDo {
	return s.Clauses(dbresolver.Read)
}

func (s socialElectricityConsumptionDo) WriteDB() *socialElectricityConsumptionDo {
	return s.Clauses(dbresolver.Write)
}

func (s socialElectricityConsumptionDo) Session(config *gorm.Session) *socialElectricityConsumptionDo {
	return s.withDO(s.DO.Session(config))
}

func (s socialElectricityConsumptionDo) Clauses(conds ...clause.Expression) *socialElectricityConsumptionDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s socialElectricityConsumptionDo) Returning(value interface{}, columns ...string) *socialElectricityConsumptionDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s socialElectricityConsumptionDo) Not(conds ...gen.Condition) *socialElectricityConsumptionDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s socialElectricityConsumptionDo) Or(conds ...gen.Condition) *socialElectricityConsumptionDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s socialElectricityConsumptionDo) Select(conds ...field.Expr) *socialElectricityConsumptionDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s socialElectricityConsumptionDo) Where(conds ...gen.Condition) *socialElectricityConsumptionDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s socialElectricityConsumptionDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) *socialElectricityConsumptionDo {
	return s.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (s socialElectricityConsumptionDo) Order(conds ...field.Expr) *socialElectricityConsumptionDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s socialElectricityConsumptionDo) Distinct(cols ...field.Expr) *socialElectricityConsumptionDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s socialElectricityConsumptionDo) Omit(cols ...field.Expr) *socialElectricityConsumptionDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s socialElectricityConsumptionDo) Join(table schema.Tabler, on ...field.Expr) *socialElectricityConsumptionDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s socialElectricityConsumptionDo) LeftJoin(table schema.Tabler, on ...field.Expr) *socialElectricityConsumptionDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s socialElectricityConsumptionDo) RightJoin(table schema.Tabler, on ...field.Expr) *socialElectricityConsumptionDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s socialElectricityConsumptionDo) Group(cols ...field.Expr) *socialElectricityConsumptionDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s socialElectricityConsumptionDo) Having(conds ...gen.Condition) *socialElectricityConsumptionDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s socialElectricityConsumptionDo) Limit(limit int) *socialElectricityConsumptionDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s socialElectricityConsumptionDo) Offset(offset int) *socialElectricityConsumptionDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s socialElectricityConsumptionDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *socialElectricityConsumptionDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s socialElectricityConsumptionDo) Unscoped() *socialElectricityConsumptionDo {
	return s.withDO(s.DO.Unscoped())
}

func (s socialElectricityConsumptionDo) Create(values ...*model.SocialElectricityConsumption) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s socialElectricityConsumptionDo) CreateInBatches(values []*model.SocialElectricityConsumption, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s socialElectricityConsumptionDo) Save(values ...*model.SocialElectricityConsumption) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s socialElectricityConsumptionDo) First() (*model.SocialElectricityConsumption, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.SocialElectricityConsumption), nil
	}
}

func (s socialElectricityConsumptionDo) Take() (*model.SocialElectricityConsumption, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.SocialElectricityConsumption), nil
	}
}

func (s socialElectricityConsumptionDo) Last() (*model.SocialElectricityConsumption, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.SocialElectricityConsumption), nil
	}
}

func (s socialElectricityConsumptionDo) Find() ([]*model.SocialElectricityConsumption, error) {
	result, err := s.DO.Find()
	return result.([]*model.SocialElectricityConsumption), err
}

func (s socialElectricityConsumptionDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SocialElectricityConsumption, err error) {
	buf := make([]*model.SocialElectricityConsumption, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s socialElectricityConsumptionDo) FindInBatches(result *[]*model.SocialElectricityConsumption, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s socialElectricityConsumptionDo) Attrs(attrs ...field.AssignExpr) *socialElectricityConsumptionDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s socialElectricityConsumptionDo) Assign(attrs ...field.AssignExpr) *socialElectricityConsumptionDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s socialElectricityConsumptionDo) Joins(fields ...field.RelationField) *socialElectricityConsumptionDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s socialElectricityConsumptionDo) Preload(fields ...field.RelationField) *socialElectricityConsumptionDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s socialElectricityConsumptionDo) FirstOrInit() (*model.SocialElectricityConsumption, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.SocialElectricityConsumption), nil
	}
}

func (s socialElectricityConsumptionDo) FirstOrCreate() (*model.SocialElectricityConsumption, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.SocialElectricityConsumption), nil
	}
}

func (s socialElectricityConsumptionDo) FindByPage(offset int, limit int) (result []*model.SocialElectricityConsumption, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s socialElectricityConsumptionDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s socialElectricityConsumptionDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s socialElectricityConsumptionDo) Delete(models ...*model.SocialElectricityConsumption) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *socialElectricityConsumptionDo) withDO(do gen.Dao) *socialElectricityConsumptionDo {
	s.DO = *do.(*gen.DO)
	return s
}
